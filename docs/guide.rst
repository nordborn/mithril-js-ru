=================================
Руководство Mithril JS Framework
=================================

**********
Вступление
**********

Что такое Mithril
=================

Mitrhil - это JavaScript MVC-фреймворк для клиентских приложений, представляющий из себя инструмент для разделения кода приложения на слой данных Модель (Model), слой пользовательсокго интерфейса (UI) Вид (View) и связующий слой Контроллер (Controller).

Объем сжатого кода Mithril составляет примерно 7кБ благодаря его компактному и выразительному API. Он предоставляет вам в распоряжение движок шаблонов с отслеживанием изменений в виртуальном DOM (virtual DOM) для производительного отображения елементов страницы, утилиты для высокоуровневого моделирования через функциональную композицию (functional composition), а также поддерживает маршрутизацию и создание компонентов (componentization).

Цель Mithril состоит в том, чтобы сделать ваши приложения расширяемыми, читаемыми и поддерживаемыми, а вас - даже лучшим разработчиком, чем вы являетесь сейчас :) 

В отличие от некоторых других фреймворков, Mithril старается не завлечь вас в ловушку зависимостей: вы можете использовать лишь некоторые возможности фреймоворка в соответствии с вашими нуждами.

В то же время, использование полного набора предоставляемых инструментов может дать дополнительные выгоды: изучение подходов функционального программирования и освоение лучших практик программирования для ООП (объектно-орентированного программирования) и MVC - лишь часть из них.

******************
Простое приложение
******************

Минимальный шаблон
==================

Подгрузив копию Mithril, для начала работы вам требуется минимальный код шаблона:

.. code:: js

  <!doctype html>
  <title>Todo app</title>
  <script src="mithril.min.js"></script>
  <script>
  //здесь будет приложение
  </script>

И да, это правильный (валидный) HTML5! В соответствии со спецификацией, тэги <html>, <head> и <body> могут быть пропущены, так как соответствующие им DOM элементы будут неявно вставлены браузером во время отображения страницы.

Модель
======

В Mithril приложение обычно живет в пространстве имен (namespace) и содержит компоненты. **Компоненты - это просто структуры, которые обеспечивают отображение страницы или ее части**. 

Дополнительно приложение может быть разделено на три основных слоя: Модель, Вид и Контроллер.

Для простоты наше приложение будет иметь только один компонент и мы собираемся использовать его как простраство имен для нашего приложения.

В Mithril **компонент - это JS-объект, содержащий две функции: controller и view**.

.. code:: js

  //пустой компонент Mithril
  var myComponent = {
      controller: function() {},
      view: function() {}
  }

В дополнение к функциям controller и view, компонент может быть использован для хранения данных, относящихся к нему.

Давайте создадим компонент

.. code:: js

  <script>
  //это приложение имеет только один компонент: todo
  var todo = {};
  </script>

Обычно записи (entities) модели являются переиспользуемыми и существуют отдельно от компонентов (например, var User = [...]). В нашем примере все приложение будет в реализовано в одном компоненте и мы собираемся использовать этот компонент как простраство имен для записей модели.

.. code:: js

  var todo = {};

  //для простоты мы используем этот компонент как простроанство имен для классов модели

  //класс Todo class имеет два свойства
  todo.Todo = function(data) {
      this.description = m.prop(data.description);
      this.done = m.prop(false);
  };

  //класс TodoList - это список элементов Todo
  todo.TodoList = Array;

``m.prop`` является просто фабрикой для геттеров и сеттеров. Геттеры-сеттеры работают так:

.. code:: js

  //объявить геттер-сеттер для начального значения `John`
  var a_name = m.prop("John");

  //прочитать значение
  var a = a_name(); //a == "John"

  //установить значение `Mary`
  a_name("Mary"); //Mary

  //прочитать значение
  var b = a_name(); //b == "Mary"
  
Обратите внимание, что классы Todo и TodoList определены выше как констукторы на чистом JavaScript. Они могут быть инициализированы и использованы как в примере ниже: 

.. code:: js

  var myTask = new todo.Todo({description: "Write code"});

  //прочитать описание (description)
  myTask.description(); //Write code

  //выполнено?
  var isDone = myTask.done(); //isDone == false

  //отметить как выполненное
  myTask.done(true); //true

  //теперь точно выполнено
  isDone = myTask.done(); //isDone == true

**Класс TodoList - это просто псевдоним встроенноого класса Array**.

.. code:: js
  
  var list = new todo.TodoList();
  list.length; //0

В соответствии с классическим определением шаблона проектирования MVC, слой модели отвечает за хранение данных, управление состоянием и бизнес-логику (на уровне данных). 

Вы можете видеть, что описанные выше классы подходят под эти критерии: они имеют свойства и методы, которые потребутся для хранения состояния. Можно создавать экземпляры Todo с изменяемымми свойствами. TodoList может иметь элементы, являющиеся экземплярами Todo, которые могут быть добавлены с помощью встроенного метода push. И так далее. 

Вид-Модель
==========

Следующим шагом напишем вид-модель, который будет использовать наши классы моделей. **Вид-модель - это сущность слоя модели, которая хранит состояние пользовательского интерфейса (UI)**. Во многих фреймворках состояние UI в основном хранится в контроллере, но такой подход делает код трудно масштабируемым, так как изначально контроллеры не разрабатывались для хранения данных. В Mithril данные состояния пользовательского интерфейса понимаются как данные модели даже при том, что они не обязательно соответствуют объектно-реляционной связи (ORM) хранимых данных.

Вид-модель также отвечает за обработку бизнес-логики, связанной с пользовательским интерфейсом. Для примера, форма может иметь поле ввода или кнопку отмены.  В этом случае используемый вид-модель отвечает за отслеживание текущего состояния поля ввода, сравнивает с начальным состоянием и разрешает отмену при необходимости. При событии, возникающем при сохранении формы, вид-модель делегирует сохранение данных более соответствующей ORM-сущности.

В случае с нашим todo-приложением, вид-модель должен реализовывать следующее: отслеживать список выполняющихся задач (todo) и поле добавления новых задач, а также отбрабаывать логику добавления каждой задачи (todo) и последствия этого действия для пользовательского интерфейса (UI)

.. code:: js

    //определить view-model
    todo.vm = {
        init: function() {
            //список выполняющихся задач
            todo.vm.list = new todo.TodoList();

            //поле для хранения названия новой задачи перед ее созданием
            todo.vm.description = m.prop('');

            //функция добавления задачи к списку, после добавления очищает поле описания для удобства пользователя
            todo.vm.add = function(description) {
                if (description()) {
                    todo.vm.list.push(new todo.Todo({description: description()}));
                    todo.vm.description("");
                }
            };
        }
    };

Код выше опредедяет вид-модель под названием ``vm``. **Это просто объект javascript, который имеет функцию init**. 
Данная функция иницииализирует объект ``vm`` с тремя полями: 
#. list - свойство, являющееся просто массивом
#. description - свойство, являющееся функцией ``m.prop`` (геттер-сеттер) с пустой строкой в качестве начального значения 
#. add - методом добавления нового экземпляра Todo в свойство list в случае, если вводимое название (поле description) не является пустой строкой. 
    
The code above defines a view-model object called vm. It is simply a javascript object that has a init function. This function initializes the vm object with three members: list, which is simply an array, description, which is an m.prop getter-setter function with an empty string as the initial value, and add, which is a method that adds a new Todo instance to list if an input description getter-setter is not an empty string.
